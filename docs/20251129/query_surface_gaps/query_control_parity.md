# Query API Control Parity Gap

- **What’s missing:** `ClaudeAgentSDK.query/2` always routes to `Process.stream/3` unless SDK MCP servers are present, so options that require the control protocol (`hooks`, `can_use_tool`, runtime agents, non-default permission modes) are ignored for the one-shot API. Python’s `query()` supports streaming/control mode by accepting an `AsyncIterable` prompt and wiring hooks/permissions through the same control stack.
- **Evidence (Elixir):** `lib/claude_agent_sdk/query.ex:23-63` only switches to the control-aware client when `mcp_servers` include an SDK server; hooks or permission callbacks do not trigger the control path. The API surface also only accepts a string prompt, with no streaming variant to satisfy the control protocol prerequisites.
- **Evidence (Python):** `anthropics/claude-agent-sdk-python/src/claude_agent_sdk/query.py:20-98` accepts `prompt: str | AsyncIterable[dict]`; `InternalClient.process_query` (`_internal/client.py:21-87`) enforces streaming when `can_use_tool` is set and passes hooks into `Query.initialize`, enabling control messages even from the convenience `query()` API.
- **Impact:** Elixir callers using the simple `query/2` path cannot exercise hooks or permission callbacks (and may see silent no-ops) unless they manually drop to `ClaudeAgentSDK.Client`. This is a functional regression relative to Python’s ergonomic entrypoint.
- **Proposed fix:** Add transport selection that considers hooks/permission callbacks/agents/permission modes, or provide a streaming-capable `query/2` overload (or `query_stream/2`) that drives the control client. Validate via tests that `can_use_tool` and hooks fire when invoked through the high-level API.
